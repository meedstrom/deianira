#+TITLE: Deianira
#+AUTHOR: Martin Edström
#+EMAIL: meedstrom@teknik.io
#+LANGUAGE: en
# Copying and distribution of this file, with or without modification,
# are permitted in any medium without royalty provided the copyright
# notice and this notice are preserved.  This file is offered as-is,
# without any warranty.

[[https://img.shields.io/badge/license-GPL3+-blue.png]]

#+begin_html
<a title="Giulio Bonasone, CC0, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Bust_of_Hercules_and_Dejanira_MET_DP812684.jpg"><img width="256" align="center" alt="Bust of Hercules and Dejanira MET DP812684" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8c/Bust_of_Hercules_and_Dejanira_MET_DP812684.jpg/256px-Bust_of_Hercules_and_Dejanira_MET_DP812684.jpg"></a><br><br>
#+end_html

# TODO: More consistent "we", "you", "I"
# TODO: More consistent "hotkey", "key sequence", "key", "key binding" .. try to pick one.

A [[https://github.com/abo-abo/hydra][hydra]]-based =which-key= banisher.  In some ways the opposite of [[https://gitlab.com/jjzmajic/hercules.el][Hercules.el]] (a "which-key based hydra banisher"), whose namesake slayed the Hydra but was then slain by his wife, the [[https://en.wikipedia.org/wiki/Deianira][princess Deianira]].

* Paradigm

Imagine that after you press the Control key, Emacs behaves as if Control is still pressed for everything you do next, and then that if you press Meta, Emacs switches to behaving as if Meta is pressed.  That's basically what this package does.

The angel's in the details, however.  If it only did the above, that'd be boring, but the sum of its parts is a whole new input paradigm.

The paradigm is:

1. All existing key bindings get copied into hydras.
2. Control, Meta, Super (and Alt and Hyper if you have them) all become "leader keys" which spawn a hydra specific to each.
   - You may know that Spacemacs and Doom Emacs have a thing with the Space key.  That's a leader key.  You get up to five of them.  Why we abuse the modifier keys this way will become apparent, read on.
3. "Homogenized keymaps": we forbid any difference between keys such as ~C-x C-e~ and ~C-x e~; we bind both to the same command, so it won't matter if you keep holding down Control or not.
   - Necessary since I want every keybinding to be typeable by pressing each key in isolation separately, e.g. the sequence ~<ctl> x e~ maps to ~C-x e~, but a sequence like ~<ctl> x <ctl> e~ would have 4, count them, 4 isolated key presses and releases in sequence. It'd be Just Bad, so we don't use it and are left with no obvious key sequence that would map to ~C-x C-e~.  Plus, we use the Control key to restart the input sequence, often useful.
4. Forbid mixing modifiers: we don't allow key sequences with more than a single modifier, like ~C-M-f~, ~M-%~ or  ~C-c M-o~.  I find these gratuitously painful, and anyway there's no way to bring them over to our hydra system without sacrificing other aspects.
5. Forbid the Shift key in any key combination or sequence.  That means regardless of which hydra you're in, typing ~F~ or ~(~ just self-inserts those characters and slays the hydra.
   - My biggest gripe with Vim is its excessive use of capitals, that I find about as uncomfortable as Control combos, a strange oversight in its design.
6. Forbid Space and Enter in any key combination or sequence.  Like the capitals, these always self-insert.
   - See Consequences for the reason.
7. Forbid Backspace in any key combination or sequence.  This is used to travel "up" the key sequence, i.e. return to the parent hydra, much like if you type a command in Vim's /ex/ command line and then backspace because you changed your mind -- there's no need to retype the key sequence from scratch.  It's cognate to =which-key-undo-key=.

The consequences are:

1. We can do transient exits.  In the Control hydra, we can press e.g. ~M-f~ like usual to move forward by word, without exiting the Control hydra.  This applies to all our hydras, even cases like the Control-X-prefix, so instead of the default ~C-x t C-n C-x t C-n C-x t~...  you can stay in the Control-X-prefix and do ~t C-n t C-n t~... This would not be possible if we allowed more than one modifier in a hotkey.
   - In this example, =repeat= wouldn't have helped since you're cycling between two different commands, making it useless.
2. We can feel as though we are in Vim's Normal mode and yet not have to press =i= or =a= to enter its Insert Mode, because capital letters (including capital symbols such as parens), spaces and newlines will self-insert and slay the hydra at the same time.  This works so well because the first character you type is frequently from this set, and it's nearly free because we (or I) didn't want Shift hotkeys anyway.
   - I might extend the set to include the period, comma and apostrophe, but that would cost real estate.
3. I find it more intuitive than [[https://github.com/emacsorphanage/god-mode][god-mode]]. There is no weird leader key like ~<escape>~ or whatever you'd choose for it, or the Spacemacs ~M-m~, instead you press the same modifier keys you always have -- Control and Meta -- and the Space key doesn't have any special behavior.
4. We pretty much get modal editing without its drawbacks.  Both due to the fast switch to "insert mode" (the state of having no active hydra), and the ability to transiently-exit any hydra as described elsewhere, i.e. to access any "mode's" commands from any other mode without having to turn it on and off.
   - In the rest of this document, I avoid the term "mode" but speak of root hydras (the root level of the Control, Meta or Super trees).
   - For example, instead of entering a mode, running a command, exiting it, and returning to whichever mode you were in, as with the hypothetical sequence ~<meta> f <meta> <ctl>~, it's faster to just ~M-f~ in whatever hydra you were and remain in that hydra.  This is one of the most /valid/ uses of modifier chords I've seen, otherwise so maligned for ergonomics.
5. We can use a compressed hotkey notation, such as ~Cxp~ instead of ~C-x p~, since it's still unambiguous.
   - Comes from the fact that the first character is always a modifier, and that after homogenizing, modifiers aren't reused.  Even ~sxp~ is unambiguous (mapping to ~s-x p~).
     # Not strictly true: how would you parse C<up>>? But <> are shift keys on US QWERTY, so they're effectively illegal, making <up> unambiguously the up arrow key.
     # Also: it'd be nice to be able to speak of partial sequences, assuming you're already in a hydra. For that to be unambiguous, we have to rename the Super prefix to upcase S or any other upcase letter.  After all, we never use the Shift key.

My motivations were:

- I wanted a genuinely modifier-free life (even dropping Shift), and I decided I don't mind typing more to get that.  Longer key sequences beat modifiers.  As a happy side effect of implementing the vision, I found we need surprisingly little extra typing this way, and sometimes even /less/, because we exploit hydras to their fullest, and several exploitations are only possible with the strict rules we impose on the keymap.
- I asked myself as a thought experiment how one would use Emacs with an [[https://olkb.com/][OLKB Planck]] or other tiny keyboard.  This constraint sprouted many ideas.  Among other things, I wanted to bind all commands to lowercase letters, and with Deianira you can.  The Planck won't ever have to use its "Raise" or "Lower" hardware modes just to access a command.  Please observe that no part of the design was sacrificed to support tiny keyboards -- I actually prefer [[https://geekhack.org/index.php?topic=116622][enormous]] keyboards -- and the good fit is a side effect.

No "paradigm lock-in"

- We rely on an external Linux utility, dual-function-keys, to turn Control, Meta and Super into leader keys, even while they continue to work as modifiers.  But even should the utility stop working, we won't be left dead in the water.  Deianira's helpers for mass-remapping bindings will still work, so your bindings will remain in the location you were expecting.  You'll just have to do one of two things:
  1. Chord at first to start a key sequence, like a normal Emacsian (boo hiss).  Even forgetting about the hydra system, the remaps you've made along the way remain accessible.
  2. Resort to =xmodmap= or equivalent tool to wholesale remap the keys normally labelled "Ctrl" and "Alt" to send different key events entirely.  You can no longer chord, but it's a small loss, because you get to keep Hydra.  In fact, I suggest this trick anyway as the most important of the [[Training wheels][Training wheels]].

# - It should be possible to create a half-Deianira that relies on sticky keys and a whole lot of repeat maps, but I suspect it won't be the same.  The full Deianira is simple in end use because you can expect the interface to be regular and uniform.

* Necessary setup
If you have a question, welcome to file a GitHub issue or send a message to https://reddit.com/u/meedstrom.
# or Matrix username?

** Getting the package

If you have [[https://github.com/raxod502/straight.el][straight.el]], you can install the package like so:

#+begin_src elisp
(use-package deianira
  :straight (deianira :type git :host github :repo "meedstrom/deianira"))
#+end_src

Alternatively with Doom Emacs, this goes in =packages.el=:

#+begin_src elisp
(package! deianira :recipe (:host github :repo "meedstrom/deianira"))
#+end_src

** dual-function-keys

You need [[https://gitlab.com/interception/linux/plugins/dual-function-keys][interception-tools]] with its included plugin dual-function-keys.  If your distro does not package it, I'm sorry to say this step may take you some work.  On Arch and Guix it's easy.

The buggy and unmaintained [[https://github.com/alols/xcape][xcape]] is NOT an alternative.  Something so fundamental needs to be reliable.  In Deianira's youth, I tried it and found a glut of issues: it could work fine for a while and then develop a 2-second latency with keystrokes, whereupon the computer had to be rebooted.  This leads to giving up on Deianira.

Possible alternatives:
- QMK firmware -- if you always use a keyboard with it QMK firmware
- Hawck
- ...

*** What is it for?
Emacs cannot detect the fact that you held down and released Control, Meta or Super, so some software lower in the stack needs to tell Emacs about it.  Thus, we configure dual-function-keys to send separate key events when this happens.  It does not matter which key events will represent this as the user almost never sees them printed in the echo area -- the default is F20, F21, F22, F23 and F24.

*** Installation

On Arch, install like so:

: sudo pacman -S interception-dual-function-keys

Let there be two config files, with the following filenames.

- =/etc/interception/udevmon.yaml=
- =/etc/interception/dual-fn.yaml=

Fill them with copypasta from the following sections.  This won't have any effect on your system right now, though it may on the next boot.

**** udevmon.yaml

#+begin_src yaml
- JOB: "intercept -g $DEVNODE | dual-function-keys -c /etc/interception/dual-fn.yaml | uinput -d $DEVNODE"
  DEVICE:
    EVENTS:
      EV_KEY: [ KEY_LEFTCTRL, KEY_LEFTALT, KEY_LEFTMETA, KEY_RIGHTCTRL, KEY_RIGHTALT, KEY_RIGHTMETA ]
#+end_src

**** dual-fn.yaml

#+begin_src yaml
TIMING:
  DOUBLE_TAP_MILLISEC: 0
  # TAP_MILLISEC: 200 # default 200

MAPPINGS:
  # Control
  - KEY: KEY_LEFTCTRL
    TAP: KEY_F21
    HOLD: KEY_LEFTCTRL

  - KEY: KEY_RIGHTCTRL
    TAP: KEY_F21
    HOLD: KEY_RIGHTCTRL

  # Emacs calls this "Meta"
  - KEY: KEY_LEFTALT
    TAP: KEY_F23
    HOLD: KEY_LEFTALT

  - KEY: KEY_RIGHTALT
    TAP: KEY_F23
    HOLD: KEY_RIGHTALT

  # Emacs calls this "Super"
  - KEY: KEY_LEFTMETA
    TAP: KEY_F24
    HOLD: KEY_LEFTMETA

  - KEY: KEY_RIGHTMETA
    TAP: KEY_F24
    HOLD: KEY_RIGHTMETA

  # The kernel doesn't name syms for what Emacs calls Alt or Hyper. I don't know
  # which keycodes would be recognized as such on Wayland, if any.  On Xorg it's
  # easy enough to use xmodmap to make a keycode-to-keysym or keysym-to-keysym
  # mapping.
#+end_src

**** Test

To test, execute this shell command in some terminal.  You can stop the effect by interrupting the terminal with Ctrl-C.

: sudo nice -n -20 udevmon -c /etc/interception/udevmon.yaml

With the program active, you should expect that pressing Ctrl, Alt or Super in Emacs will yield a message like "<f21> is undefined".  Make sure you see that sort of message for all three modifier keys, both the left and right variants, so you know they all work.

After verifying the above, type =M-x deianira-mode RET= and see what now happens when you press Ctrl, Alt or Super.  You get hydras?  Great!

Please mind that this is just a test -- later on, I'll recommend some more lisp in your initfiles.

*** If you wish to change the keys

The keys we've chosen to represent presses of Control/Meta/Super must be listed doubly -- once in the file =dual-fn.yaml=, and once in the following Customizable variables.

- =dei-ersatz-alt= (default ="<f20>"= )
- =dei-ersatz-control= (default ="<f21>"= )
- =dei-ersatz-hyper= (default ="<f22>"= )
- =dei-ersatz-meta= (default ="<f23>"= )
- =dei-ersatz-super= (default ="<f24>"= )

If you wish to change a keysym, change it in both places!

In addition, though it can be superfluous, ensure that the keysyms exist in your current Xkb keymap table, by also customizing =dei-xmodmap-rules= -- see the current value, I expect it's self-explanatory what to do.

**** Which keysyms?

Here's a small selection of choices.  I tried to find ones that alliterate.

| Kernel keysym | Xkb keysym    | Emacs keysym    | Kernel code | Xkb code |
|---------------+---------------+-----------------+-------------+----------|
| KEY_F20       | F20           | <f20>           |         190 |      198 |
| KEY_F21       | F21           | <f21>           |         191 |      199 |
| KEY_F22       | F22           | <f22>           |         192 |      200 |
| KEY_F23       | F23           | <f23>           |         193 |      201 |
| KEY_F24       | F24           | <f24>           |         194 |      202 |
| KEY_FRONT     | SunFront      |                 |         132 |      140 |
| KEY_CANCEL    | Cancel        |                 |         223 |      231 |
| KEY_HELP      | Help          |                 |         138 |      146 |
| KEY_SEARCH    | XF86Search    | <XF86Search>    |         217 |      225 |
| KEY_CUT       | XF86Cut       | <XF86Cut>       |         137 |      145 |
| KEY_MAIL      | XF86Mail      | <XF86Mail>      |         155 |      163 |
| KEY_HOMEPAGE  | XF86HomePage  | <XF86HomePage>  |         172 |      180 |
| KEY_NEXTSONG  | XF86AudioNext | <XF86AudioNext> |         163 |      171 |
| KEY_KATAKANA  | Katakana      | <katakana>      |          90 |       98 |
| KEY_HIRAGANA  | Hiragana      | <hiragana>      |          91 |       99 |
| KEY_HENKAN    | Henkan        | <henkan>        |          92 |      100 |
| KEY_MUHENKAN  | Muhenkan      | <muhenkan>      |          94 |      102 |

- More kernel keysyms: https://github.com/torvalds/linux/blob/master/include/uapi/linux/input-event-codes.h
- More Xorg keysyms: run =xmodmap -pke= or see https://gist.github.com/siarie/61247ee2bb70f1146484f852f845c1b7

**** Wayland

Under Wayland, you most likely *have to* change the keys.

The problem is you don't get fully free choice of keysym as you do on Xorg, and the default tables rarely have wild keysyms like ~F20~ through ~F24~ or ~Mail~ that would be safe to use.   (Yes, xmodmap can seem to work, but only momentarily.  Under Sway, the keymap table quickly reverts to some original determined by the Xkb settings you've set in the Sway config file.)

I've found a few keys that do tend to work:  =<katakana>=, =<muhenkan>=, =<henkan>=, and =<hiragana>=.  If you write Japanese, you'll have to find some other keys -- I wish you luck.

To find other choices, print out the full table via =xmodmap -pke= and pick some keysyms you don't need, test those.

Unfortunately, while many syms look like they should work, surprisingly many did not for me.  (If someone can help: they existed both in the [[https://github.com/torvalds/linux/blob/master/include/uapi/linux/input-event-codes.h][Linux kernel keymap]] and my =xmodmap -pke=, with the correct difference of +8 in the scancode, and still Emacs saw absolutely no key event!)

***** Custom Xkb layout

It seems that wlroots-based compositors like Sway use the Xkb system, even if programs like xmodmap do not work.

Most common layouts under Xkb have neither Alt nor Hyper, so even on X11 you'd use xmodmap to bring them into existence.   In lieu of xmodmap, it should be possible to just load a .xkb file that contains Hyper and Alt.  Basically start by generating a =custom.xkb= with xkbcomp and modify, as per:
https://wiki.archlinux.org/title/X_keyboard_extension#Meta,_Super_and_Hyper

Then =sway input xkbfile custom.xkb= should do it.

I expect this will also let you get F20-F24 and whatever other keys you like.

*** Guix System

I don't yet know how to write an on-boot service, but creating =udevmon.yaml= inside the system declaration allows you to hardcode the store paths, as per Guix standard practice.  After that, you have all you need to run an oneliner.

#+begin_src scheme
(packages
 (cons* ...
        interception-tools
        interception-dual-function-keys
        ...))
(services
 (cons* ...
        (extra-special-file
         "/etc/interception/udevmon.yaml"
         (mixed-text-file "udevmon.yaml"
                          "- JOB: \""
                          interception-tools "/bin/intercept"
                          " -g $DEVNODE | "
                          interception-dual-function-keys "/bin/dual-function-keys"
                          ;; NOTE: change this filesystem path to wherever you keep the file
                          " -c /home/kept/system-config/dual-fn.yaml | "
                          interception-tools "/bin/uinput"
                          " -d $DEVNODE\"
  DEVICE:
    EVENTS:
      EV_KEY: [ KEY_LEFTCTRL, KEY_LEFTALT, KEY_LEFTMETA, KEY_RIGHTCTRL, KEY_RIGHTALT, KEY_RIGHTMETA ]
"))
        ...))
#+end_src

Execute this Bash in some TTY and you're ready to go.  Re-execute it every boot.

: sudo nice -n -20 udevmon -c /etc/interception/udevmon.yaml

(For those just running GNU Guix as a package manager, follow the Arch instructions instead, I think it'll work.)

** Basic initfile snippet

#+begin_src elisp
(require 'deianira)
(add-hook 'dei-keymap-found-hook #'dei-homogenize-all-keymaps)
(deianira-mode)
#+end_src

Additionally, if you have =(setq hydra-is-helpful nil)= somewhere in your initfiles, you'll now probably want to remove that and let it be =t=.
# TODO: code in a check+warning instead of readme, people don't read instructions.  Let user disable the check.

** Homogenizing

From before, the line that keeps your keys homogenized is =(add-hook 'dei-keymap-found-hook #'dei-homogenize-all-keymaps)=.

You can check the buffer =*Deianira remaps*= to see what it's doing.  Note that there is no way to undo.  To get back all your bindings, comment out that line and restart Emacs.

Tip: If you enjoy the homogenized keymaps, you can keep using that part of Deianira without ever turning on deianira-mode.

*** Choose what to keep

You'll want to customize =dei-homogenizing-winners= over time.   Do you use ~C-x f~ or ~C-x C-f~ more?  It's hard to know when thinking about it.  But this is *absolutely key* to becoming comfortable.

The variable comes with some defaults, but I advise overriding them with your own setting.  See its docstring for more info.

#+begin_src elisp
(setq dei-homogenizing-winners
  '(("C-c C-c")
    ("C-x C-f")
    ("C-x C-s")
    ("C-x C-;")
    ("C-x a")
    ("C-x g")
    ("C-x b")
    ("C-x n")
    ("C-x p")
    ("C-g")
    ("C-h C-g")
    ("M-g")
    ("C-c C-c" . org-mode-map)
    ("C-c C-," . org-mode-map)))
#+end_src

*** Superfluous entries in which-key

If you want to keep which-key for the occasional use-case, this snippet will hide the superfluous entries.

#+begin_src elisp
;; Hide the duplicate keys that arose from Deianira homogenizing.
(with-eval-after-load 'which-key
  (cl-pushnew '((" .-." . nil) . t) which-key-replacement-alist))
#+end_src

** Training wheels
** Out of GNOME hell :noexport:
* Optional setup
** C-g alternative

Since ~C-g~ is normally bound to keyboard-quit, pressing ~g~ in the Control hydra will do what you'd expect (the same thing as ~C-g~), but I advise against getting in the habit of using it.  It's so prone to muscle-memorization and when you're in the Meta hydra or any other hydra, ~g~ /will do something else/.  Some naive recourses could be:

- 1. Bind ~g~ to keyboard-quit in every hydra, i.e. bind ~M-g~, ~s-g~, ~M-s g~, ~C-x g~ and so on, or:
- 2. Avoid pressing ~g~ in the Control hydra; press ~C-g~ always
- 3. Press Control and ~g~ sequentially.

All three have issues. #1 still will need ~C-g~ when no hydra is active. With #2, it's a chord, and we wanted to be free of chords (and I'd realistically never keep up that discipline). Perhaps more natural is #3, but if Emacs freezes up it won't work, so if I may recommend a bold alternative:

- 4. Bind some other key to do what ~C-g~ did.

Everyone's got a different origin story with Emacs, but when you first learned ~C-g~ in the tutorial, I expect you must have been bemused.  Maybe you got used to it and haven't thought about it since, but it's a bizarre binding.  Such a fundamental action should only take one keystroke -- maybe even a convenient place like Tab or Return.

I picked Escape.  I put the following in my init file.  After a short period of feeling like I was committing sacrilege, it felt natural like I'd been waiting to do it this way all my life.  Try it!

: (define-key input-decode-map (kbd "<escape>") (kbd "C-g"))

Note that when Emacs freezes up, you cannot break the freeze with ~<escape>~, and all of a sudden ~C-g~ is what you must type to break it, no other key will do.  Maybe ~C-g~ is hardcoded for that.  Try for yourself: eval =(sleep-for 5)= and try to break out of it.  Escape won't work.  But this is the only inconsistency I've experienced.

** Universal argument: ~C-u M-d~, Brutus?

The default bindings for universal-argument and digit-argument present a problem.

1. C-123456890 and M-123456890 are a huge waste of good keys.
  - Why are the ten keys M-1234567890 bound to digit-argument, but we're too stingy to bind one more key, ~M-u~, to universal-argument?
3. Having =universal-argument= only on ~C-u~ breaks the ideal we were going for, of never mixing modifiers:
   - a. Ever had to type ~C-u 0 M-x~?  I wanted to jump out the window too.
   - b. It's a similar issue as with ~C-g~; the universal argument should be available under every modifier, and for us also every hydra. In other words if we stick to =u=, we want ~C-u~, ~C-x u~, ~M-u~, ~M-s u~, ~s-u~ etc.  But we needn't stick to =u=, more on this later.

Note: This is not a particular consequence of Deianira.  The issue just sticks out like a sore thumb under our paradigm.  Binding only ~C-u~ but not ~M-u~, so you end up having to switch modifier midway through typing a command, as in =C-u 0 M-x byte-recompile-directory=... It's made tolerable by the fact that all of C-1234567890 and M-1234567890 are digit-argument by default, so that example can be made into =M-0 M-x.=

If we unbind the digit arguments, we can deal with the loss by making it more convenient to use the universal argument.  By default, to do ~M-d~ 9 times you have to type ~C-u 9 M-d~.  The solution, if sticking with ~C-u~ for universal-argument, we'll make it also possible to type ~M-u 9 M-d~ as well as ~M-u M-9 M-d~ (this last form provides most comfort). And in a hydra you can simply type =u9d=. Then it should be less scary to get rid of M-123456890.

You notice that in the above example, we needed to bind ~M-u~, implying we bound every possible =u= combo: ~M-u~, ~s-u~, ~C-x u~ &c.  I do not recommend it.  If you pick a dedicated key such as ~<f12>~ instead, it's an equal waste of keys in theory since you could've used that to start a key sequence, but:

1. it's a shame to spend an alphabetic character on this, they're best reserved for semantics.  The use of =u= can aid remembering commands like =up-list= and =upcase-word=.
2. universal-argument isn't important enough for such a good key as ~u~, in my experience
3. it's nice to exploit Deianira by bringing in all key sequences under the umbrella of the root hydras, so we wouldn't put a sequence on ~<f12>~ anyway

A clean-feeling alternative could be the character ~=~, i.e. the keys ~C-=~, ~M-=~, ~C-x =~ so on, since (on a US QWERTY keyboard) it's right next to ~-~, but I for one just don't use =universal-argument= that much.

I find the negative argument is the most useful of them all, and I keep the bare ~-~  key bound in every hydra (just like having ~C--~, ~M--~, and company) but if you want to really conserve keys, I suggest picking a location for the universal argument such that it is easy to type together with ~-~. On my laptop, that's ~<print>~ since it's just above and to the right. Or you could relocate =negative-argument= itself to, let's say, ~<f11>~, with =universal-argument= on ~<f12>~.

Here is an example of a complete fix including moving universal-argument to ~C-=~, ~M-=~ and company, instead of ~C-u~, ~M-u~ and company:

#+begin_src elisp
;;; Fix prefix arguments
(define-key global-map (kbd "C-u") nil)
(define-key universal-argument-map (kbd "C-u") nil)
(define-key universal-argument-map (kbd "=") #'universal-argument-more)
(define-key universal-argument-map (kbd "-") #'negative-argument)

;; Don't waste good keys (C-123456890) on digit arguments.
;; But make it more convenient to access them in other ways.
(let ((modifiers '("C-" "M-" "s-" "H-" "A-"))
      (digits (split-string "1234567890" "" t)))
  (dolist (mod modifiers)
    (define-key global-map (kbd (concat mod "-")) #'negative-argument)
    (define-key global-map (kbd (concat mod "=")) #'universal-argument)
    (define-key universal-argument-map (kbd (concat mod "=")) #'universal-argument-more)
    (dolist (d digits)
      (define-key global-map (kbd (concat mod d)) nil) ;; unbind
      (define-key universal-argument-map (kbd (concat mod d)) #'digit-argument))))
#+end_src

Ensure the hydras reflect your choice:
#+begin_src elisp
(setq dei-extra-heads
  '(("=" dei-universal-argument)
    ("-" dei-negative-argument)
    ("<f5>" hydra-repeat)))

(setq dei-invisible-leafs
      (seq-difference dei-invisible-leafs '("-" "=")))
#+end_src

If you want to use a dedicated key like =<print>= instead, replace occurrences of ~=~ with =<print>= and add another line:
#+begin_src elisp
(define-key global-map (kbd "<print>") #'universal-argument)
#+end_src

Some packages override M-1234567890.  Prevent that:

#+begin_src elisp
(with-eval-after-load 'ranger
  ;; Don't take my M-1234567890
  (let ((digits (split-string "1234567890" "" t)))
    (dolist (d digits)
      (define-key ranger-normal-mode-map (kbd (concat "M-" d)) nil)
      (define-key ranger-emacs-mode-map (kbd (concat "M-" d)) nil))))

(with-eval-after-load 'magit
  ;; Don't take my M-1234567890
  (define-key magit-section-mode-map (kbd "M-1") nil)
  (define-key magit-section-mode-map (kbd "M-2") nil)
  (define-key magit-section-mode-map (kbd "M-3") nil)
  (define-key magit-section-mode-map (kbd "M-4") nil))
#+end_src

** Mass-remapping
* Imagined FAQ
** Can I keep which-key?
Yes.

** What if you just use sticky keys and carefully crafted repeat-maps instead of all this crap?
Not the same thing -- you'd additionally need god-mode, and you'd still need to setup dual-function-keys or similar software so as to make the Control and Meta keys into entry-points for god-mode's modes.  Then we can compare.  If you do that, I'll link your blog post here!

** Can you use this without the drastic "homogenizing" remapping?
No.  Or there will be a lot of keys you can't reach from hydra, and the paradigm is broken.  Worse, if we have /bastard sequences/ (see terminology) or differing definitions between chord-once and perma-chord sequences (see terminology), it introduces a layer of doubt that interferes with you memorizing the sequence -- as your muscle memory can't "cross-train" between what happens inside the hydra and what happens outside it.

Note that we remap only in a structural way, according to a few fixed rules.  Sometimes these rules poke us in the eye, but aside from them, we're carefully non-opinionated.  In another package, ergoemacs-mode, they move ~M-x~ to ~M-a~, a wonderful improvement but the kind of decision Deianira doesn't involve itself in.

** Why do you hate Shift?  Shift is great!
Shift has some surprising utilities.  But to understand what makes it unique, here's a thought experiment.

Consider an experiment where you have another key replace all the use cases of Shift.  Let's say we choose the ~s~ key, as a short for "Shift" because we're sentimental.

Now instead of binding anything to say, ~<f1> K~, you bind ~<f1> s k~.  You'll note it's the same number of key presses (3), and probably more comfortable.

It's more comfortable than Shift because Shift has flaws:

- Shift needs to be held down.  (You can solve this with the "sticky keys" feature on many OSes.)
- Shift is typically hit with the pinky finger.  (You can solve this with a non-standard keyboard that gives it to a thumb.)

Even after solving both of these issues, the Shift-involved key sequence will only approach the comfort of the Shift-free key sequence, not meaningfully exceed it.

So why ever involve Shift in a hotkey?  Especially considering you may not always have sticky keys, nor a specialty keyboard?  Reasons I've found:

1. Mnemonics
2. /Because/ it chords

Reason 1 doesn't by itself stand up to the drawbacks (my opinion), so let's look at Reason 2.  It's subtle.

(The below is probably easier to understand after you've used Deianira)

With Deianira, the ~<f1> s ...~ keys get collected into a new hydra.  This much you know.

Now if we want that hydra to faithfully reflect the Shift experience, we have to make a tradeoff.  Should it reflect Shift-with-Sticky-Keys, or chord-Shift?  The latter case is easy, it's just Deianira's default behavior (well, it doesn't in fact touch Shifted keys, but in principle).

For the former, we'd need a new type of "temporary" hydra where once you execute any key in it, you exit, but /you go up only one level/, i.e. you come back to the ~<f1> ...~ hydra rather than exiting fully.

If instead of the ~s~ key, you use the actual Shift key like a normal person, you get to /choose/ depending on the context.  Sticky Shift does not preclude chord-Shift on occasion.  So you can hold down Shift and spam something while sitting in the ~<f1> ...~ hydra.

/That/ is the unique utility of Shift.  It's not much, but it's there.  We could probably generalize this benefit with a massive round of [[https://github.com/emacsorphanage/key-chord/][key-chord.el]] mappings inside each and every hydra.  I won't tackle that project.

** I'm a layman.  Why is this package so complex?  It seems simple, what it does?

1. KEYMAPS. Like a lot of software, Emacs binds keyboard keys to commands.  Unlike most software, Emacs doesn't just have one static list of key-bindings, but keeps hundreds of separate lists which it calls "keymaps".  Each may bind the same keys to different commands!  To determine what a given key should /in fact/ do, Emacs consults a composite of all the relevant keymaps for the current context, considering rules of precedence.  One problem is that this composite changes rapidly, and we use a technology (hydra) that defines keys in a static way.  A technical challenge then becomes to continuously update these hydras to reflect the current composite.
2. KEY SEQUENCES.  Also unusual among software, Emacs has key sequences.  We want to make hydras to reflect /in which step/ of the sequence we are sitting.  This is half the package's raison d'etre, and increases complexity as we must now make the hydras refer to each other in a predictable way.
3. AVOIDING MODIFIERS  Having solved 1 and 2, we've done a lot already to avoid modifiers.  However there may be bound two sequences C-x f and C-x C-f to different commands.  And we don't want to press Ctrl again.  So we instead bash together the sublists of keys, some involving a chord and some not, into chord-free lists, so that we won't need to type C-f in that example.  However, there's a horrific amount of edge cases, such as when one keymap binds a single key and another keymap binds the same key to a sub-keymap, and we must resolve this conflict neatly, and plug in the user's preferences along the way.
4. PERFORMANCE.  The package must continuously keep its state matching the truth of the context -- not just the hydras (1) but the bashing together of key bindings (3).  Since it may do so as often as every keystroke, and we don't want any input latency. performance becomes a challenge, and we must devise ways to let the computer work as little as possible.
* Vision
** Which engine?

Despite the name, Deianira is not necessarily a Hercules killer, but could be remade to run on top of it.  In fact, there's a range of potential engines for the Deianira paradigm:

1. Hydra
2. Hercules
3. [[https://tildegit.org/acdw/define-repeat-map.el][define-repeat-map]]
4. Transient

(I'd like an engine-agnostic term for the concept shared by all these.  Please hit me up.  For now, the term "hydra" is short and useful: it can become verbs and adjectives like "hydraize", "hydrable", even other nouns like "hydratics".  In addition, you can speak of "flocks" of hydras and of "spawning" and "slaying" them.)

While it looks straightforward enough to rewire the package to use the other options, I'm not convinced we get any important benefit from options 2 or 3.  What about option 4, tarsius' Transient package?  It may have a ton of potential, which I dare not imagine because I've spent enough years thinking about hotkeys and if I'm right, that would blaze a new path full of new questions.

Let me explain.

The famous collection of Transients known as Magit is a discoverable way to subtly modify any =git= command, beating the command line even for command line aficionados.  So sayeth Internet Truth.

If we represent all of Emacs' key bindings in Transients, the same way Magit swallowed all of Git's commands, the benefit is unclear compared to doing it just with Hydra, because most of the time, you do not want to modify a command anyway.  But that very fact may boil down to us now having separate commands for all of the following, as a result of not having had Transient in the distant past of 1980:

- transpose-chars (C-t)
- transpose-words (M-t)
- transpose-sexps (C-M-t)
- transpose-lines (C-x t)
- transpose-sentences
- transpose-paragraphs
- transpose-regions
- avy-transpose-lines-in-region
- crux-transpose-windows

These commands speak of one *verb* "transpose", together with a variety of targets or *objects* "char", "word", "sexp", "line" and so on.  We see a similar pattern for the verb "kill":

- kill-word (M-d)
- kill-line (C-k)
- kill-sexp (C-M-k)
- kill-buffer (C-x k)
- kill-comment
- kill-whole-line
- kill-process
- kill-emacs
- ....

And so on it goes; the pattern is everywhere in Emacs.  With such a cornucopia of predefined commands, it's natural that they rarely need modifying.

Deianira cooperates with this; it just uncreatively brings in existing key bindings under a hydra, so you get precisely the subset of Emacs commands that had key bindings (a few hundred).  By contrast, to properly use Transient's potential, you'd find ways to call every one of Emacs' 3,000+ commands, and maybe by accident create whole crops of new commands that don't yet exist.

It's easy to imagine a Transient that has just one key for the verb "transpose", one key for the verb "kill", one key for the object "char", one key for the object "word" and so on, and then you add adverbs and adjectives.  Once you get to this point, you've reinvented Vim.  But with the masterpiece that is Transient, maybe we could do better than Vim, beating the "Vim paradigm" even for Vim paradigm aficionados, like Magit beats the command line paradigm?

As heady as that vision sounds, I'm skeptical whether it'd manage to do much better.  That's where I suggest Deianira can come in, as one of a set of twins that together beats Vim at Vimgolf.  Maybe I'm just dreaming.

** How easy would it be to change engine?

I don't know, but it would not become any simpler.  If you imagine that using the Emacs 28 repeat-maps would uncomplicate the code -- no, it would still be 2k lines of code, maybe more.

* Notes
** Note on extra modifiers
If your keyboard is blessed with extra thumb keys, you may be able to acquire Hyper and Alt for a total of five leader keys.  If so, you could move most of what you use from under ~C-h~, ~C-x~, ~M-g~, ~M-s~ etc to just ~H-~ and ~A-~, but I believe the advantage is small if you already curate the ~C-~  and ~M-~ prefixes since:

1. We have many discomfort mitigations in place.
2. It isn't actually good to spread your leaves under many different prefixes.  It's something you do to shorten key sequences, but because we have hydras, many keys are now already as short as they can be, and switching prefix becomes an extra action!  The more well-filled one prefix, the less likely you'll have to switch prefix while exploiting a hydra.  Thus, you'll benefit more from curating the 2-3 modifiers you already have, than from acquiring extra modifiers.

On a standard keyboard, Control/Alt/Super aren't in comfortable places, and then you may want to minimize the amount of switching between root hydras, and instead travel among a single root hydra's children, going in and out of nested key sequences with the help of Backspace.   However it's true that if you had 5 modifiers in really comfortable places and they were full of shallow key bindings, no deep key sequences, this may be preferable to the Backspace method.  I'm undecided.  It seems highly vulnerable to the choice of where you bind each command: it could be good or it could be terrible, needing you to change prefix very often.  Commands you're likely to call after each other should live in the same prefix.  So this mandates careful design.  See also [[#vision][Vision]].

** Concepts/terminology
*** Permachord and chord-once

The rule of homogenized keymaps imply the following:

1. ~C-x k e~ is legal
2. ~C-x C-k e~ is illegal
3. ~C-x k C-e~ is illegal
4. ~C-x C-k C-e~ is legal, but must be bound the same as \#1.

I call the variant at \#1 a /chord-once sequence/ and the variant at \#4 a /permachord sequence/.  The act of "homogenizing" a binding is just making sure \#1 and \#4 are bound to the same command.  By default, =dei-permachord-wins-homogenizing= is nil, meaning that the command bound at \#1 will be copied to \#4, overriding what was on \#4.

As for the middle variants, \#2 and \#3, I call them 'bastard sequences', because they result from a copulation no one wanted.  These among others are unbound by =dei--unbind-illegal-keys=.

Aside: I would recommend leaving =dei-permachord-wins-homogenizing= at nil, for two reasons.
- You can define keys in initfiles as "C-x k e" instead of "C-x C-k C-e", which looks more neat.
- Not exactly every sequence can be typed in perma-chord fashion.  A typical example is Org-mode's ~C-c C-e l o~, which is actually just ~C-c C-e~, which spawns a new buffer wherein you type ~l o~.  As a consequence, you can still effectively type the chord-once variant ~C-c e l o~, but we don't yet have code to make ~C-c C-e C-l C-o~ a thing.  Since this is such a rare edge case, we probably never will.  So for psychological reasons, you'll be less misled if you think of \#1 as the 'authoritative version'.


*** Bastard sequence
- C-c p 4 C-d  (projectile)
- C-c C-e l o  (org)

These are examples of bastard sequences.  Basically those that have you hit a modifier, release it halfway and maybe hit it again at different points.  They often arise accidentally or due to history.  Whoever knowingly binds such a key is not okay.

*** Key sequence

Standard Emacs term.  A sequence of keys of any number of steps, any of which may include chords.  Technically, a single key such as <f3>, or a chord such as C-M-f, is a key sequence of one step.

*** Multi-chord

A chord involving more than one modifier, such as C-M-f.

*** Single-pair chord

A chord that only involves one modifier, such as C-f.

*** Mixed-modifier sequence

A key sequence that involves more than one modifier, such as C-c M-o or C-M-w (which is also a multi-chord).

*** Key

In Emacs vocabulary, a "key" can mean a chord such as C-M-f, which in my opinion is best thought of as three keys.  Until we come up with a new term for what it is that's happening thrice in C-M-f ("key presses"?), it's worth paying attention to how the term is used.

*** Stem and leaf
# :CUSTOM_ID: stemleaf

The source code makes a lot of references to "stem" and "leaf".  See =dei--get-leaf=.  In human language, the leaf is the last part of a key description (the kind of string you'd pass to =kbd=) that can correspond to an event.  The way Emacs thinks of it is different, and a necessity from the realities of keyboards: to our keyboards, or at least to some of the OS' plumbing, a key like ~C-<return>~ can be considered a /single/ event, not two.  A control-modified character is simply a different character altogether.  This is impractical for me to work with, since it maps poorly to how I think about hotkeys.

If you dive into the source, be aware of what a "stem" is.  A full key description like =C-x a= is split /without deleting any character/ into the stem "C-x " and the leaf "a". Note the trailing space in the stem.  This is necessary to disambiguate the stem "C-x " from the valid key description =C-x=.  Other examples follow.

| Key description | Stem   | Leaf       |
| =C-x a=           | "C-x " | "a"        |
| =C-x=             | "C-"   | "x"        |
| =C-<M-return>=    | "C-M-" | "<return>" |

If programming against this library, always wrap a key description in =(key-description (kbd KEY))= to safeguard against odd descriptions like =C-<M-return>=: the other functions expect a normalized key description, in this case =C-M-<return>=.

*** Quitter
*** Quasi-quitter
* Surprising powers

Power 1. You can use digit arguments on commands bound to the same digit, by backspacing out of the prefix-argument-adapted hydra. Here we assume that <print> is your universal argument key, what normies call C-u:
: <ctl> x <print> 3 <backspace> 3  ;; calls C-x 3 with argument 3

Power 2. You can insert prefix arguments anywhere inside a key sequence rather than only at the start.  These are all equivalent:
: <ctl> x <print> 3 <backspace> 3
: <ctl> <print> 3 <backspace> x 3
: <print> 3 <ctl> x 3

Power 3. When a desktop environment like GNOME clobbers your ~s-a~ chord, you can still access it by typing ~<super> a~. Similarly, on many systems Alt+F4 tries to kill your Emacs, but you can type ~<meta> <f4>~ to reach its real binding, if you gave it one.

* Known issues
** Hydra does not update instantly
If you run a command such as =next-buffer= from within a hydra, getting a different buffer with potentially different major mode and keymaps, the hydra will not reflect this, but continue to reflect the buffer where it was first called.

Aside from confusion, it's usually not a problem because in a supermajority of cases, the difference is only visual: it's the hydra /hint/ that reflects the wrong buffer's bindings.  The keys still do what they should, since they are not bound to specific commands but to =(call-interactively (key-binding KEY))=, which results in the correct action.

In some cases, the behavior is different:
- It can happen that the command should be bound to a sub-hydra but isn't.
- The heads' individual =:exit= flags also do not change, so they can be inappropriate for the current buffer, not reflecting =dei-quitter-keys= or related variables.

** Chord reflection binds every possible combination

If you've chosen to clone all Control keys to Super keys with =(add-hook 'dei-keymap-found-hook #'dei-update-super-reflection)=, unfortunately you get a lot of superfluous bindings.  Taking the example of cloning ~C-x C-k C-t~ to ~s-x s-k s-t~, the following six additional keys will appear in the outputs of your =describe-keymap= and =describe-bindings=:

- C-x C-k s-t
- C-x s-k C-t
- C-x s-k s-t
- s-x s-k C-t
- s-x C-k C-t
- s-x C-k s-t

It's annoying in =describe-keymap= output, but they will be hidden the =which-key= popup, if you apply the fix in [[#superfluous-entries-in-which-key][Superfluous entries in which-key]].  It doesn't affect the user, so it's a low priority.

The technical reason this happens: it's because ~s-x~ is bound simply to =Control-X-prefix=, a keymap.  In addition, ~C-x~ is also bound to that keymap. Looking inside that keymap, you can find the key ~C-k~ and now also ~s-k~...  The way keymaps are designed, it's hard for us to bind /only/ ~C-x C-k C-t~ and ~s-x s-k s-t~.  Binding both of these key sequences means binding every possible combination.  In theory, it can be done by using =copy-keymap= to avoid operating in the same keymaps.

* Thanks

I owe thanks to [[https://github.com/abo-abo][abo-abo]] and the other contributors to Hydra.  If I'd had to wrangle =god-mode= or =which-key= to my purposes, I would have needed to know a lot more about the Emacs hotkey internals than I did starting out.  With Hydra, I could just hack and experiment, and incrementally arrive to where I am.  There's something right about it, it's a friendly API that allows you to iteratively learn as you bend it towards your needs, so it's a fine member of the Emacs ecosystem.
